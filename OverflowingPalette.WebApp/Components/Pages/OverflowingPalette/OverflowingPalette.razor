@page "/overflowing-palette"

@using global::OverflowingPalette.Shared.Models
@using global::OverflowingPalette.WebApp.Services
@using global::OverflowingPalette.WebApp.Components.Pages.OverflowingPalette.Components
@using static global::OverflowingPalette.Shared.Constants.Constants

@inject GameService GameService

<PageTitle>Overflowing Palette</PageTitle>

<div class="container bg-dark">
    <div class="row">
        <div class="col-10">
            @for (int i = 0; i < Height; i++)
            {
                <div class="row">
                    @foreach (var square in AnimatedSquares.Skip(i * Width).Take(Width))
                    {
                        <AnimatedSquareComponent Square="@square"
                                                 SelectedColor="@SelectedColor"
                                                 ChangeNeighborsColor="@ChangeNeighborsColor" />
                    }
                </div>
            }
        </div>
        <div class="col-2">
            @foreach (var color in Colors!)
            {
                <div class="row">
                    <div class="col-8">
                        <button class="btn rounded-circle p-5 m-2 border border-4 @IsColorSelected(color)" @onclick="() => ChangeSelectedColor(color)" style="background-color: @color" />
                    </div>
                    <div class="col-4 p-0 align-self-center">
                        @if (string.Equals(SelectedColor, color))
                        {
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="white" class="bi bi-triangle-fill" viewBox="0 0 16 16" transform="rotate(270)">
                                <path fill-rule="evenodd" d="M7.022 1.566a1.13 1.13 0 0 1 1.96 0l6.857 11.667c.457.778-.092 1.767-.98 1.767H1.144c-.889 0-1.437-.99-.98-1.767z" />
                            </svg>
                        }
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    private const int Width = 10;
    private const int Height = 8;
    private readonly HashSet<(int, int)> Offsets = [(0, 1), (1, 0), (0, -1), (-1, 0)];

    private IEnumerable<string>? Colors = Array.Empty<string>();
    private List<AnimatedSquare> AnimatedSquares = new List<AnimatedSquare>();
    private string? SelectedColor { get; set; }
    private bool IsProceeding = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Colors = await GameService.GetColorsAsync();
            AnimatedSquares = GameService.GetAnimatedSquares().ToList();
            SelectedColor = Colors.FirstOrDefault() ?? string.Empty;

            StateHasChanged();
        }
    }

    private async Task ChangeNeighborsColor(AnimatedSquare clickedSquare)
    {
        if (IsProceeding)
        {
            return;
        }

        IsProceeding = true;

        Dictionary<int, List<(AnimatedSquare square, string animationClass)>> animationPlan = new();
        Queue<(AnimatedSquare square, int depth, (int offsetX, int offsetY) direction)> queue = new();
        HashSet<(int, int)> visited = new();

        queue.Enqueue((clickedSquare, 0, (0, 0)));
        visited.Add((clickedSquare.PositionX, clickedSquare.PositionY));

        while (queue.Any())
        {
            var (currentSquare, depth, direction) = queue.Dequeue();

            if (!animationPlan.ContainsKey(depth))
            {
                animationPlan[depth] = new();
            }

            animationPlan[depth].Add((currentSquare, GetAnimationClassFromStart(clickedSquare, currentSquare)));

            foreach (var (offsetX, offsetY) in Offsets)
            {
                var newRow = currentSquare.PositionX + offsetX;
                var newCol = currentSquare.PositionY + offsetY;

                if (newRow >= 0 && newRow < Height && newCol >= 0 && newCol < Width &&
                    !visited.Contains((newRow, newCol)))
                {
                    var neighbor = GetSquare(newRow, newCol);

                    if (neighbor is not null
                        && neighbor.Color == clickedSquare.Color)
                    {
                        queue.Enqueue((neighbor, depth + 1, (offsetX, offsetY)));
                        visited.Add((newRow, newCol));
                    }
                }
            }
        }

        foreach (var depthLevel in animationPlan.Keys.OrderBy(key => key))
        {
            foreach (var (square, animationClass) in animationPlan[depthLevel])
            {
                square.PreviousColor = square.Color;
                square.Color = SelectedColor;
                square.AnimationClass = animationClass;
            }

            StateHasChanged();
            await Task.Delay(100);
        }

        IsProceeding = false;
    }

    private AnimatedSquare? GetSquare(int row, int col)
    {
        int index = row * Width + col;
        return index >= 0 && index < AnimatedSquares.Count ? AnimatedSquares[index] : null;
    }

    private void ChangeSelectedColor(string color)
    {
        if (IsProceeding)
        {
            return;
        }

        SelectedColor = color;
    }

    private string IsColorSelected(string color)
    {
        return string.Equals(SelectedColor, color) ? CssClasses.BorderWhite : CssClasses.BorderDark;
    }


    private string GetAnimationClassFromStart(AnimatedSquare startSquare, AnimatedSquare currentSquare)
    {
        if (startSquare == currentSquare) 
        {
            return string.Empty;
        }

        int totalDifferenceX = currentSquare.PositionX - startSquare.PositionX;
        int totalDifferenceY = currentSquare.PositionY - startSquare.PositionY;

        return (totalDifferenceX, totalDifferenceY) switch
        {
            var (differenceX, differenceY) when Math.Abs(differenceX) > Math.Abs(differenceY) =>
                differenceX > 0 ? AnimationStyles.FromTop : AnimationStyles.FromBottom,

            var (differenceX, differenceY) when Math.Abs(differenceY) > Math.Abs(differenceX) =>
                differenceY > 0 ? AnimationStyles.FromLeft : AnimationStyles.FromRight,

            ( > 0, > 0) => AnimationStyles.FromTopLeft,
            ( < 0, > 0) => AnimationStyles.FromBottomLeft,
            ( > 0, < 0) => AnimationStyles.FromTopRight,
            ( < 0, < 0) => AnimationStyles.FromBottomRight,
            _ => AnimationStyles.None
        };
    }
}
